\include{settings}
\usepackage{amsmath}

\begin{document}	% начало документа

% Титульная страница
\include{titlepage}

% Содержание
\include{ToC}


\section{Цель работы}
Познакомиться с понятием корреляции и функцией корреляции. 


\section{Теоретическая информация}
В данной лабораторной работе будем рассматривать корреляционный анализ. Его смысл состоит в количественном измерении степени сходства различных сигналов. Для этого будем использовать специальные корреляционные функции. Так, для получения взаимной корреляции двух последовательностей, имеем следующую формулу:
\begin{equation} r_{12}(j) = \frac{1}{N} \sum\limits_{n = 0}^{N - 1} x_1(n) x_2(n + j) = r_{12}(-j) =  \frac{1}{N} \sum\limits_{n = 0}^{N - 1} x_2(n) x_1(n - j) \end{equation}
Здесь j - это смещение одного сигнала относительно другого.

Так же можно ввести аналогичную формулу для непрерывной временной области:
\begin{equation} r_{12}(\tau) =  \lim_{T \to \infty} \frac{1}{T} \int_{-T/2}^{T/2} x_1(t)x_2(t + \tau) dt  \end{equation}

Рассчет корреляции можно ускорить, воспользовавшись следующей формулой:
\begin{equation} r_{12}(j) = \frac{1}{N}F_D^{-1}[X_1^*(k)X_2(k)] \end{equation}
Здесь, $F_D^{-1}$ - обратное преобразование Фурье.
При различной длине сигналов выполнить расчет корреляции можно путем добавления к двум последовательностям дополняющих нулей. Если последовательность $x_1(n)$ имеет
длину N1, а последовательность $x_2(n)$ — N2, то $x_1(n)$ дополняется (N2 − 1) нулями,
а $x_2(n)$ — (N1 − 1) нулями. Далее на основе двух расширенных последовательностей
рассчитывается взаимная корреляция.

\section{Ход выполнения работы}
Имеем сигнал, сосотоящий из нолей и единиц - [0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0] и синхропосылку - [1, 0, 1]. Задача - найти положение синхропосылки в сигнале. Изначально преобразуем все ноли в -1. Это необходимо для корректной работы алгоритма быстрого расчета корреляции сигналов, так как сигнал будет дополняться нолями. Корреляцию рассчитаем с помощью встроенной функции correlate библиотеки numpy. Алгоритм для быстрого расчета корреляции напишем самостоятельно используя преобразования Фурье из той же библотеки. Результаты представлены на Рисунке.~\ref{pic:result}

\lstinputlisting[
	label=code:CorrelLab,
	caption={CorrelLab.py},% для печати символ '_' требует выходной символ '\'
]{CorrelLab.py}
\parindent=1cm % командна \lstinputlisting сбивает параментры отступа
%Текст без отступа (следует за вставкой)%

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{result}
		\caption{Результаты работы прямого и быстрого расчетов корреляции} 
		\label{pic:result} % название для ссылок внутри кода
	\end{center}
\end{figure}

Наблюдаем более быструю работу прямого алогоритма, что является очень странным. Обе функции проделывали расчет миллон раз, а затем на основе этого было вычисленно среднее время, затраченное на один рассчет корреляции этой функцией. Можем сделать предположение, что быстрый алгоритм работает эффективней с большим количеством данных.
Стоит отметить, что оба алгоритма выполнили свою задачу и определили положение синхропосылки. В данном случае начало синхропосылки отмечено цифрой 3.

Чтобы проверить или опровергнуть наше предположение о том, что быстрый алогритм работает эффективней с большим количество данных, проведем еще один опыт. Значения последовательности синхропоссылки менять не будем, однако увеличим наш сигнал, сгенерируя случайную последовтельность нолей и единиц большей размерности, например, равной 10000. Цикл, в котором расчитывается корреляция, уменьшим до 1000 итераций. Получаем следующие неутешительные результаты.(Рисунок.~\ref{pic:result1})

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{result1}
		\caption{Результаты работы прямого и быстрого расчетов корреляции для расширенного сигнала} 
		\label{pic:result1} % название для ссылок внутри кода
	\end{center}
\end{figure}

Наблюдаем колоссальную разницу во времени работы обеих функций. 
\section{Выводы}
Проделав лабораторную работу, рассмотрели понятие корреляции и научились пользоваться двумя алгоритмама её расчета. Установили, что прямой алогритм поиска корреляции более быстро рассчитывает корреляцию, чем быстрый алгоритм. При этом, увеличивая сигнал, время работы быстрого алгоритма начинает значительно отдаляться от времени работы прямого алгоритма. Отсюда можем сделать предположение, что некоторые встроенные функции, использованные при написании быстрого алгоритма, работают неоптимально.
\end{document}



